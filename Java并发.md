什么是线程，与进程的区别

阅读源代码，并学会使用

Thread、ThreadLocal、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors

线程池

自己设计线程池、submit() 和 execute()

线程安全

死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系

## Java锁事

Java中一般按照是否含有某一特性来定义锁，可以通过特性将锁进行分组归类，如下图所示。

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png)

### 乐观锁 VS 悲观锁

乐观锁和悲观锁是一种广义上的概念，体现了看待线程同步的不同角度，在Java和数据库中都有此概念的实际应用。

对于同一个数据的并发操作，悲观锁认为在使用数据时一定会有其他线程来修改数据，所以在获取数据前先加锁，确保数据不被其他线程修改，Synchronized关键字和Lock的实现类都是悲观锁。乐观锁认为在使用数据时不会有其他线程修改，所以不会添加锁，只是在更新数据之前先判断数据有没有被其他线程修改，如果没有修改，那么当前线程将自己修改的数据写入，如果已经被其他线程更新，则根据不同的实现方式执行不同操作（报错或重试）。乐观锁在Java中通过使用无锁编程来实现，最常使用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现。

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/c8703cd9.png)

从上述对比可知：

1. 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确
2. 乐观锁适合读操作多的场景，不加锁可以使读操作的性能大幅提升

> 悲观锁和乐观锁的调用方式对比
>
> ```java
> // ------------------------- 悲观锁的调用方式 -------------------------
> // synchronized
> public synchronized void testMethod() {
> 	// 操作同步资源
> }
> // ReentrantLock
> private ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁
> public void modifyPublicResources() {
> 	lock.lock();
> 	// 操作同步资源
> 	lock.unlock();
> }
> 
> // ------------------------- 乐观锁的调用方式 -------------------------
> private AtomicInteger atomicInteger = new AtomicInteger();  // 需要保证多个线程使用的是同一个AtomicInteger
> atomicInteger.incrementAndGet(); //执行自增1
> ```
>
> 悲观锁在显示加锁之后再操作同步资源，而乐观锁是直接去操作同步资源

### CAS

乐观锁的主要实现方式是CAS，CAS全称Compare And Swap，是一种无锁算法，在不适用锁的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS实现了乐观锁。

#### CAS算法基本逻辑

CAS算法涉及三个操作数：

- 需要读写的内存值V
- 进行比较的值A
- 要写入的新值B

当前仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值（“比较”+“更新”整体是一个原子操作），否则不会执行任何操作，一般情况下，更新是一个不断重试的操作。

#### AtomicInteger CAS实现分析

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/feda866e.png)

- unsafe：获取并操作内存的数据
- valueOffset：存储value在AtomicInteger中的偏移量
- value：存储AtomicInteger的int值，该属性通过volatile保证其可见性

AtomicInteger的自增函数incrementAndGet()底层是调用的unsafe.getAndAddInt()

```JAVA
// ------------------------- JDK 8 -------------------------
// AtomicInteger 自增方法
public final int incrementAndGet() {
  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}

// Unsafe.class
public final int getAndAddInt(Object var1, long var2, int var4) {
  int var5;
  do {
      var5 = this.getIntVolatile(var1, var2);
  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
  return var5;
}

// ------------------------- OpenJDK 8 -------------------------
// Unsafe.java
public final int getAndAddInt(Object o, long offset, int delta) {
   int v;
   do {
       v = getIntVolatile(o, offset);
   } while (!compareAndSwapInt(o, offset, v, v + delta));
   return v;
}
```

getAndInt()循环获取给定对象o中的偏移量offset处的值v，然后判断内存值是否等于v，如果相等将内存值设置为v + delta，否则循环重试，直到设置成功后退出循环，并且将旧值返回。"比较" + "更新"操作封装在compareAndSwapInt()中，在JNI中是借助cmpxchg指令完成的，属于原子操作，可以保证多个线程能够看到同一个变量的修改值。

#### CAS存在的问题

1. ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有变化才会更新内存值。但如果内存值原理是A，后来变成B，然后又被改成A，那么CAS检查时会发现值没有变化。ABA问题解决思路是在变量前添加版本号，每个变量更新时版本号加一。JDK从1.5提供了AtomicStampedReference来解决ABA问题，具体操作封装在compareAndSet中，该方法会检查当前引用和当前标志是否与预期引用和预期标志相等，如果相等则更新
2. 循环时间长开销大。CAS操作如果一直不成功，会导致其一直自旋，给CPU带来非常大的开销
3. 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但对多个变量进行操作时，CAS无法保证操作的原子性。JDK从1.5开始提供AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里进行CAS操作

### 自旋锁 VS 适应性自旋锁

阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态变换需要消耗CPU时间，如果同步代码块中内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。在大部分场景中，同步资源锁定的时间很短，为了这一段时间去切换线程，线程挂起和恢复的时间可能远远超出等待的时间。如果物理机制有多个处理器，能够让多个线程并行执行，就可以让后面那个请求锁的线程不放弃CPU的执行时间，等待之前持有锁的线程释放锁。

为了让线程等待，需要让当前线程自旋，如果在自旋完成后锁已经释放，那么当前线程就可以直接获取同步资源，避免线程切换的开销，这就是自旋锁。

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png)



自旋锁不能代替阻塞，自旋虽然避免了线程切换的开销，但要占用处理器时间，如果锁被占用的时间很长，自旋线程会一会占用处理器资源。所以自旋等待的时间必须有限度，如果自旋超过了限定次数（默认是10，可以用-XX：PreBlockSpin来更改）没有获得锁，就应该进入阻塞状态。

JDK6之后自旋锁默认开启（-XX:UseSpining），并且引入了适应性自旋锁。适应性自旋锁的等待时间不再固定，而是由前一次在同一个锁上的自旋时间以及拥有锁的线程状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程在运行中，那么JVM就认为这次自旋也很有可能获得锁，进而允许其自旋更长的时间。如果对于某个锁，自旋很少成功获得过，那么以后尝试获取这个锁时会减少等待时间或者直接进入阻塞，避免浪费处理器资源。

### synchronized

synchronized是一种同步锁，实质上是给对象加了一把锁，Java中的每一个对象都可以作为锁。具体表现为以下三种形式：

- 普通同步方法：锁是当前对象实例
- 静态同步方法：锁是当前类的Class对象
- 同步方法块：锁是synchronized括号中配置的对象

JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。代码块同步是使用monitorenter和monitorexit指令来实现的，方法同步是使用另外一种方式实现的，细节在JVM规范中没有详细说明，但是方法的同步也可以使用这两个指令来实现。

monitorenter指令是在编译后插入到同步代码块的开始位置，monitorexit插入到方法结束和异常位置，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

#### Java对象头

synchronized是悲观锁，在操作同步资源之前需要给同步资源加锁，这把锁就是存在Java对象头里面。

HotSpot的对象头主要包含两部分数据：

- Mark Word（标记字段）：默认存储对象的HashCode，分代年龄和锁标志位信息。运行期间Mark Word存储的数据会随着锁标志位的变化而变化
- Klass Pointer（类型指针）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

#### Monitor

Monitor可以理解为一个同步工具或一种同步机制，通过被描述为一个对象。每一个Java对象都有一把看不见的锁，称为内部锁或者Monitor锁。

Monitor是线程私有的数据结构，每一个线程都有可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，标识该锁被这个线程占用。

#### synchronized的四种状态

在JDK6之后，为了减少获得锁和释放锁带来的性能消耗，引入了"偏向锁"和"轻量级锁"。所以synchronized有四种状态，级别从低到高依次是无锁、偏向锁、轻量级锁、重量级锁，锁只能升级不能降级。

| 锁状态   | 存储内容                                                | 存储内容 |
| :------- | :------------------------------------------------------ | :------- |
| 无锁     | 对象的hashCode、对象分代年龄、是否是偏向锁（0）         | 01       |
| 偏向锁   | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） | 01       |
| 轻量级锁 | 指向栈中锁记录的指针                                    | 00       |
| 重量级锁 | 指向互斥量（重量级锁）的指针                            | 10       |

#### 无锁

无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁的特点是修改操作在循环内进行，线程会不断的尝试修改共享资源，直到修改成功。CAS原理及应用就是无锁的实现。无锁不能全面代替锁，但在某些场合下无锁性能非常高。

####  偏向锁

偏向锁是指一段同步代码一直被一个线程访问，那么该线程会自动获取锁，降低获取锁的代价。

当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下减少不必要的轻量级锁执行路径，轻量级锁的获取及释放依赖多次CAS原子操作，而偏向锁只需要在置换ThreadID时进行一次CAS原子操作即可。

只有遇到其他线程竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销需要等待全局安全点（在这个时间节点上没有字节码执行），虚拟机会先暂停持有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁或轻量级锁状态。

![img](../../../%25E7%259F%25A5%25E8%25AF%2586%25E7%25AE%25A1%25E7%2590%2586/assets/3D163950-B607-4166-877A-B4E1C24F1F1B.png)

#### 关闭偏向锁

如果确定应用程序中所有的锁通常都处于竞争状态，可以通过JVM参数-XX:UseBiasedLocking=false关闭偏向锁，那么程序默认进入轻量级锁

####  轻量级锁

当锁是偏向锁的时候，被另外的线程访问，偏向锁就会升级成轻量级锁，其他线程通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。在存在竞争的情况下，使用偏向锁会频繁的暂停线程。

1. 轻量级锁加锁

线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word存储到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，。如果成功，当前线程获得锁，如果失败，当前线程使用自旋来获得锁，将Displaced Mark Word中的owner修改为当前线程ID，并将锁标志位修改为00，表示当前为轻量级锁。

2. 轻量级锁解锁

轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，表示没有竞争发生。如果失败，表示当前存在锁竞争，锁就会膨胀成重量级锁。

![img](../../../%25E7%259F%25A5%25E8%25AF%2586%25E7%25AE%25A1%25E7%2590%2586/assets/173B6440-E317-4854-9BDC-CC33A120B274.png)

####  重量级锁

当锁处于重量级锁状态时，其他线程试图获取锁，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程会进行下一轮的竞争。

#### 锁的优缺点对比

| 锁       | 优点                                                         | 缺点                                                       | 适用场景                           |
| -------- | ------------------------------------------------------------ | ---------------------------------------------------------- | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外消耗，和执行非同步方法相比仅存在纳秒级别差距 | 如果线程间存在竞争，会频繁暂停线程，带来额外的锁撤销的消耗 | 只有一个线程访问同步块场景         |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程，自旋会消耗CPU                  | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间慢                                       | 追求吞吐量，同步块执行时间长       |



### 公平锁 VS 非公平锁

公平锁是指多个线程按照申请锁的顺序来获得锁，线程直接进入队列中排队，队列中的第一个线程获得锁。公平锁的优点是线程不会饿死，缺点是整体吞吐效率相比非公平锁要低，等待队列中除第一个线程以外的线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁更大。

非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到队列中等待，但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁。非公平锁的优点是减少唤起线程的开销，整体吞吐效率高，因为线程几率不等待直接获取到锁，CPU不需要唤醒所有线程。缺点是处于等待队列中的线程可能饿死，或者很久才能获取到锁。



### 可重入锁 VS 不可重入锁

可重入锁是指同一个线程在外层方法获取到锁之后，再进入该线程的内层方法会自动获取锁（锁对象是同一个对象或者Class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁。

### 排他锁 VS 共享锁

- 排他锁：是指该锁只能被一个线程持有。如果线程T对数据A加上排他锁后，其他线程不能再对数据A加任何类型的锁。获得排他锁的线程既能读数据又能修改数据。JDK中的synchronized和LOCK的实现类就是互斥锁。
- 共享锁：共享锁可被多个线程持有，如果线程T对数据A加上共享锁后，其他线程对数据A也只能加共享锁，不能加排他锁。获得共享锁的线程只能读数据。读写锁是典型的共享锁。

数据库相关锁机制、分布式锁、锁优化、锁消除、阻塞锁、死锁

synchronized和lock之间关系、不使用synchronized如何实现一个线程安全的单例

sleep 和 wait

wait 和 notify

notify 和 notifyAll

ThreadLocal

生产者消费者问题

守护线程

守护线程和非守护线程的区别以及用法



## 参考

1. 《Java并发编程的艺术》
2. [《不可不说的Java"锁"事》](https://tech.meituan.com/2018/11/15/java-lock.html)
