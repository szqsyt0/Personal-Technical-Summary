## JAVA死锁问题定位与分析

### 死锁概念

死锁是指多个线程在运行过程中因争夺资源而造成的一种互相等待的现象，当线程处于这种僵持状态时，如果没有外力作用，都无法继续运行

### 死锁产生的必要条件

1. 互斥条件：线程要求所分配的资源进行排他性控制，即在一段时间内某资源仅为一个线程占用
2. 请求和保持条件：当线程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件：进程已获得的资源在未使用完成前，不能剥夺，只能在使用完成后主动释放
4. 环路等待条件：在发送死锁时，必然存在一个线程-资源的环形链

### 死锁避免

死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配。这是一种保障系统不进入死锁状态的动态策略，即银行家算法

### 死锁预防

1. 破坏不可剥夺条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间该进程占有的资源将被释放重新加入到系统的资源列表中，可以被其他进程使用。
2. 破坏请求与保持条件：（1）每个进程在开始执行时就申请其所需要的全部资源 （2）每个进程在申请锁需要的资源时其本身不占用系统资源
3. 破坏环路等待条件：采用资源有序分配，其基本思想是将系统中的所有资源编号，在申请资源时必须按照顺序进行申请



### 死锁检测

使用jstack dump线程快照，即可查看到哪些线程在获取哪些锁时产生了死锁



## Java Full GC问题定位与分析

https://cloud.tencent.com/developer/news/730553



常见问题解决思路

内存溢出、线程死锁、类加载冲突

当一个Java程序频繁FullGC时如何解决问题、

如何查看垃圾回收日志、

如何判断是否存在内存泄露
