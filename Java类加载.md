## 类加载机制

### Class类文件结构

Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑排列在文件之中，中间没有任何分隔符，这使得Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据时，则会按照高位在前(大端存储）的方式分割成若干个8个字节存储。

> 大端存储：是指数据的高字节，保存在内存的低地址中，数据的低字节，保存在内存的高地址中，该存储模式类似于把数据当做字符串顺序处理，地址从小到大增加，而数据从高位往低位走
>
> 小端存储：是指数据的低字节，保存在内存的低地址中，数据的高字节，保存在内存的高地址中

Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表

- 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值
- 表是由多个无符号数或其他表作为数据项构成的符合数据类型。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视为一张表。

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这一系列连续的某一类型的数据称为某一类型的集合。

#### 魔数与Class文件的版本

每个Class文件的头4个字节被称为"魔数"，其唯一作用是确定这个文件是否为一个能背虚拟机接收的Class文件。

紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号。高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》明确要求即使文件格式未发生变化，虚拟机也必须拒绝执行超过其版本号的Class文件。

![image-20201229201502827](../../../%25E7%259F%25A5%25E8%25AF%2586%25E7%25AE%25A1%25E7%2590%2586/assets/image-20201229201502827.png)

如上图所示，前4个字节的十六进制表示是0xCAFEBABE，代表次版本号的第5个和第6个字节值为0x0000，而主版本号的值为0x0032，即十进制的50，该版本号说明这个是可以被JDK6或以上版本虚拟机执行的Class文件。

#### 常量池

版本号之后的是常量池入口，常量池是Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，它还是在Class文件中第一个出现的表类型数据项目。

由于常量池数量不固定，需要在常量池入口放置一项u2类型数据，表示常量池容量计数值。该容量计数是从1而不是从0开始，如上图所示，常量池容量为（偏移地址：0x00000008）十六进制数0x0016，即十进制的22，表示常量池中有21项常量，索引值范围1~21。从1开始计数的目的是，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。Class文件结构中只有常量池容量计数从1开始，对于其他类型结合，都是从0开始。

常量池主要存放两大类变量：字面量和符号引用。字面量比较接近于java语言层面的常量概念，如文本字符串、被声明为final的常量值等。符号引用属于编译原理方面的概念，主要包括以下几类常量：

- 被模块导出或者开放的包（Package）
- 类和接口的全限定名
- 字段名称和描述符
- 方法名称和描述符
- 方法句柄和方法类型
- 动态调用点和动态常量

#### 访问标志

常量池结束之后，紧接着的两个字节代表访问标志，用于标识一些类或者接口层次的访问信息，包括这个Class是类还是接口，是否定义为public类型，是否定义为abstract类型，如果是类的话，是否声明为final等等

![image-20201230111021847](../../../%25E7%259F%25A5%25E8%25AF%2586%25E7%25AE%25A1%25E7%2590%2586/assets/image-20201230111021847.png)

#### 类索引、父类索引与接口索引集合

类索引、父类索引都是一个u2类型的数据，接口索引集合是一组u2类型的数据的集合，Class文件由这三项数据确定该类型的继承关系。类索引用于确认该类的全限定名，父类索引用于确定该类的父类的全限定名。接口索引集合用来描述这个类实现了哪些接口。类索引、父类索引、接口索引集合都按顺序排列在访问标志之后。

#### 字段表集合

字段表用于描述接口或者类中声明的变量。Java语言中的字段包括类级变量以及实例级变量，但不包括方法中的局部变量。

#### 方法表集合

方法表用于描述方法，其标识方法和字段表类似。依次包括访问标志、名称索引、描述符索引 、属性表集合。

#### 属性表集合

Class文件、字段表、方便表都可以携带自己的属性表集合，以描述某些场景专有的信息。

### 类加载的时机

一个类型从被虚拟机加载到内存开始，到卸载出内存为止，会经历加载、验证、准备、解析、初始化、使用、卸载七个阶段，其中验证、准备、解析统称为连接。这七个阶段的发生顺序如下图所示：

![image-20201230154214135](../../../%25E7%259F%25A5%25E8%25AF%2586%25E7%25AE%25A1%25E7%2590%2586/assets/image-20201230154214135.png)

上图中，加载、验证、准备、初始化、卸载这五个顺序是确定的，类型的加载过程必须按照这种顺序开始。Java虚拟机规范没有规定在什么情况下开始类加载过程的第一个阶段”加载“，但是规定了有且只有以下六种情况，必须进行初始化（加载、验证、准备必须在此之前完成）。

1. 遇到new、getstatic、putstatic或invokestatic这四条字节码时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型场景有：
   - 使用new实例化对象
   - 读取或设置一个类型的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）
   - 调用一个类型的静态方法
2. 使用java.lang.reflect包的方法对类型进行反射调用时，如果类型没有进行初始化，则触发初始化
3. 初始化类的时候如果发现其父类没有初始化，则先触发其父类的初始化
4. 当虚拟机启动时，会先初始化用户指定的主类（包含main方法的类）
5. 当使用JDK7加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeStatic四种类型的方法句柄，并且这个方法句柄对应的类没有初始化，则需要先初始化
6. 当一个接口定义了JDK8加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前初始化

接口的加载过程和类加载过程稍有不同，主要是上述第三种场景，当一个接口初始化时，并不要求其父接口都完成初始化，只有在真正使用到父接口的时候才会初始化。

### 类加载过程

#### 加载

在加载阶段，JVM需要完成以下三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

加载阶段结束后，JVM外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了。

#### 验证

验证是连接阶段的一部分，其目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。验证阶段大致会完成下面四个阶段的校验动作：

1. 文件格式验证

   验证字节流是否符合Class文件格式规范，并且能被当前版本的虚拟机处理，包含以下验证点：

   - 是否以模式0xCAFEBABE开头
   - 主、次版本号是否在当前虚拟机接收范围之内
   - 常量池的常量中是否有不被支持的常量类型
   - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
   - 。。。

   第一阶段的验证点远不止这些，该验证阶段的目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合一个Java类型信息的要求。该阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，后面的三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流

2. 元数据验证

   对字节码描述的信息进行语义分析，保证不存在与《Java语言规范》定义相悖的元数据信息，验证点如下：

   - 这个类是否有父类（除了java.lang.Object之外，所有的类都有父类）
   - 这个类的父类是否继承了不被允许继承的类（final类）
   - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
   - 。。。

3. 字节码验证

   通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的，保证被校验类的方法不会在运行时对虚拟机安全造成影响。

4. 符号引用验证

   该动作发生在解析阶段，符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗说就是该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常校验以下内容：

   - 符号引用中通过字符串描述的全限定名是否能找到对应的类
   - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段
   - 符号引用中的类、字段、方法的可访问性是否可被当前类访问
   - 。。。

   符号引用验证的目的是确保解析行为能正常执行，如果无法通过符号引用验证，JVM会抛出一个java.lang.IncompatibleClassChangeError的子类异常。

验证阶段对于虚拟机的类加载机制来说，是一个重要但不是必须执行的阶段，因为验证阶段只有通过和不通过的区别，只要通过了验证，后续就对程序运行没有影响。如果程序运行的全部代码都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

#### 准备

为类中定义的变量（静态变量）分配内存并设置类变量初始值。这时候进行内存分配的仅包括类变量，不包括实例变量。另外在准备阶段的赋值指的是数据类型的零值。除非是final static变量，会在准备阶段赋值为定义的值。

#### 解析

解析阶段是JVM将常量池内的符号引用替换为直接引用的过程。

> 符号引用：符号引用以一组符号来描述所引用的模板，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
>
> 直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能直接定位到目标的句柄。直接引用和虚拟机实现的内存布局是直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

#### 初始化

在初始化阶段，会根据程序猿的代码去初始化类变量和其他资源，初始化阶段就是执行类构造器<clinit>()方法的过程。

- <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件出现的顺序决定的，静态语句块只能访问到定义在其之前的变量，定义在其之后的变量，静态语句块可以赋值，不能访问。
- <clinit>()方法与类的构造函数不同，其不需要显示调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完成。因此在JVM中第一个被执行<clinit>()方法的是java.lang.Object
- 由于父类的<clinit>()方法先执行，意味着父类中的静态语句块要先于子类的变量赋值操作
- <clinit>()方法对于类和接口来说不是必须的，如果一个类中没有静态语句块和变量赋值操作，那么编译器不会为这个类生成<clinit>()方法
- 执行接口<clinit>()方法不需要先执行父接口的<clinit>()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的<clinit>()方法
- JVM必须保证一个类的<clinit>()方法在多线程环境下能正确地加锁同步，如果多个线程同时去初始化一个类，只会有一个类去执行类的<clinit>()方法，其他线程都需要阻塞等待。如果在一个类中的<clinit>()方法有耗时很长的操作，可能导致其他线程阻塞。

> 需要注意，其他线程虽然会被阻塞，但如果执行<clinit>()方法的线程退出<clinit>()方法后，其他线程则不会再次进入<clinit>()方法，同一个类加载器下，一个类型只会被初始化一次。

### 类加载器

#### 类与类加载器

对于任意一个类，都必须由加载它的类加载器和这个类本身共同确定其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间，比较两个类相等，只有在这两个类时由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等，包括代表Class对象的equal()方法、isIntance()、instanceof等方法。

#### 双亲委派模型

自JDK1.2以来，Java一直保持三层类加载器、双亲委派的类加载架构。绝大多数程序都会使用到一下3个系统提供的类加载器来进行加载

- 启动类加载器(Bootstrap Class Loader)：负责加载存放在$JAVA_HOME/lib目录下或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库(如rt.jar、tools.jar)加载到虚拟机的内存中。
- 扩展类加载器(Extension Class Loader)：负责加载$JAVA_HOME/ext目录中或者被java.ext.dirs系统变量所指定的路径中的类库。JDK允许用户将具有通用性的类库放置在ext目录以扩展Java SE的功能。
- 应用程序类加载器(Application Class Loader)：负载加载用户类路径(ClassPath)上所有的类库，一般情况下这个就是程序中默认的类加载器

![image-20201231160632607](../../../%25E7%259F%25A5%25E8%25AF%2586%25E7%25AE%25A1%25E7%2590%2586/assets/image-20201231160632607.png)

上图展示的各种类加载器之间的层次关系被称为类加载器的"双亲委派模型"，双亲委派模型要求除了启动类加载器外，其余的加载器都有自己的父类加载器。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，应先将请求委派给父类加载器去完成，因为所有的请求最终都会传送到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

使用双亲委派模型来组织类加载器之间的关系有如下好处：

Java中的类随着它的类加载器具备了一种带有优先级的层次关系，例如java.lang.Object，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各个类加载器环境中都能够保证是同一个类。如果没有双亲委派模型，都由各个类加载器去加载的话，如果用户自己也编写了一个名为java.lang.Object类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类。

双亲委派代码实现如下：

```java
protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
{
	// 首先，检查请求的类是否已经被加载过了
	Class c = findLoadedClass(name);
	if (c == null) {
		try {
			if (parent != null) {
				c = parent.loadClass(name, false);
			} else {
				c = findBootstrapClassOrNull(name);
			}
		} catch (ClassNotFoundException e) {
			// 如果父类加载器抛出ClassNotFoundException
			// 说明父类加载器无法完成加载请求
		}
		if (c == null) {
			// 在父类加载器无法加载时
			// 再调用本身的findClass方法来进行类加载
			c = findClass(name);
		}
	}
	if (resolve) {
		resolveClass(c);
	}
 	return c;
}
```

#### 破坏双亲委派模型

双亲委派模型主要出现过3次较大规模"被破坏"的情况。

- 第一次破坏发生在双亲委派模型出现之前，双亲委派模型在JDK1.2才被引入，而类加载器在Java的第一个版本就存在，因此为了兼容已有的代码，无法以技术手段避免loadClass()方法被覆盖，只能在JDK1.2之后的ClassLoader中加入一个新的方法findClass()，并引导用户尽量重新该方法，而不是在loadClass中编写代码。
- 第二次破坏是由双亲委派模型本身缺陷导致的。双亲委派模型很好地解决了各个类加载器协作时基础类型的一致性（越基础的类由越顶层的类加载器加载），但存在基础类型调用回用户代码的情况，如JNDI服务。JNDI是Java的标准服务，它的代码由启动类加载器完成加载。但JNDI需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDK服务提供者接口，问题是启动类加载器找不到这些类。为了解决该问题，Java团队引入了线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，将会从父线程继承一个，如果全局范围都没有设置过，那默认就是应用程序类加载器。有了线程上下文类加载器之后，JNDI服务使用该加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，实际上打通了双亲委派模型的层次结构来逆向使用加载器，已经违背了双亲委派模型的一般原则。Java中涉及SPI加载的基本都采用这种方式来完成，如JNDI、JDBC等等。
- 第三次破坏是由于用户对程序动态性的追求而导致的，动态性指的是代码热替换、模块热部署等。以OSGI为例，OSGI实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(Bundle)都有一个自己的类加载器，当需要更新一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。当收到类加载请求时，OSGI按照下面的顺序进行类搜索：
  1. 将以java.*开头的类，委托给父类加载器加载
  2. 否则，将委派列表名单内的类，委派给父类加载器加载
  3. 否则，将import列表中的类，委派给export这个类的bundle的类加载器加载
  4. 否则，查找当前bundle的ClassPath，使用自己的类加载器加载
  5. 否则，查找类是否在自己的Fragment Bundle中，如果在则委托给Fragment Bundle的类加载器加载
  6. 否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载
  7. 否则，类查找失败

### Java模块化系统

了解一下即可，JDK9引入了Java模块化系统(Java Platform Module System, JPMS)，有点类似OSGI
